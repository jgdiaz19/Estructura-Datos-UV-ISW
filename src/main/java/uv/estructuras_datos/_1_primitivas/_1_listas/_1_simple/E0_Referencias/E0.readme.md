# ğŸ“˜ PrÃ¡ctica 0: Comprendiendo las referencias y el manejo de memoria en Java

## ğŸ¯ Objetivo general

Comprender el funcionamiento de la instanciaciÃ³n de objetos y el manejo de referencias en Java como base conceptual para el estudio de listas simplemente ligadas y otras estructuras de datos.

---

## ğŸ§  Objetivos de aprendizaje

* Comprender quÃ© es una referencia en Java.
* Distinguir entre objetos iguales y referencias iguales.
* Visualizar la relaciÃ³n entre variables y objetos en memoria.
* Manipular estructuras simples de enlace usando clases personalizadas.

---

## ğŸ“š Conceptos teÃ³ricos: Referencias, punteros e instanciaciÃ³n en Java

### ğŸ”¸ Â¿QuÃ© es una referencia en Java?

En Java, cuando se crea un objeto con la palabra clave `new`, este objeto se almacena en la **memoria dinÃ¡mica (heap)**. La variable que declaras **no contiene directamente el objeto**, sino que almacena una **referencia**, es decir, un **enlace o direcciÃ³n virtual** que apunta hacia la ubicaciÃ³n del objeto en la memoria.

Es como tener una etiqueta que dice dÃ³nde vive el objeto, no el objeto mismo.

```java
Nodo a = new Nodo(5); // 'a' guarda una referencia al objeto Nodo
```

### ğŸ”¹ Â¿CÃ³mo se organiza la memoria en Java?

Cuando se ejecuta un programa en Java, la **JVM (Java Virtual Machine)** organiza la memoria en distintas Ã¡reas. Las mÃ¡s relevantes para el programador son:

| Zona de memoria   | Â¿QuÃ© almacena?                                             | Â¿QuiÃ©n la gestiona?                                        |
| ----------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| **Stack (pila)**  | Variables locales, referencias a objetos, datos primitivos | Se gestiona automÃ¡ticamente por la JVM (LIFO)              |
| **Heap (montÃ³n)** | Objetos instanciados con `new`                             | Gestionada por el recolector de basura (Garbage Collector) |

---

### ğŸ”¸ Stack (Pila)

* Es una **zona de acceso rÃ¡pido**, organizada como una **pila LIFO** (Ãºltimo en entrar, primero en salir).
* AquÃ­ se almacenan:

    * Variables primitivas (por ejemplo, `int`, `double`).
    * **Referencias** a objetos (no los objetos en sÃ­).
* Cada vez que se llama a un mÃ©todo, se crea un nuevo "marco de pila" que contiene sus variables locales.
* Cuando el mÃ©todo termina, su marco es eliminado.

ğŸ’¡ Si declaras:

```java
Nodo a = new Nodo(5);
```

* La variable `a` vive en el **stack**.
* El objeto `Nodo(5)` vive en el **heap**.

---

### ğŸ”¸ Heap (MontÃ³n)

* Es el Ã¡rea donde la JVM guarda todos los **objetos creados dinÃ¡micamente** mediante `new`.
* Los objetos permanecen en el heap hasta que **ninguna referencia los apunta**, momento en el cual el **Garbage Collector** los elimina.
* A diferencia del stack, el heap **no se organiza de forma LIFO**.
* El acceso es mÃ¡s lento que en el stack, pero permite la persistencia entre mÃ©todos o clases.

ğŸ“Œ Ejemplo:

```java
Nodo x = new Nodo(10);  // Se crea en el heap, x es referencia en el stack
```

* El objeto `Nodo(10)` estÃ¡ en el **heap**.
* La variable `x` estÃ¡ en el **stack**, conteniendo una **referencia** al objeto del heap.

---

### ğŸ”¥ Â¿QuÃ© es el Garbage Collector (GC)?

* Es un proceso automÃ¡tico de la JVM que **libera espacio del heap** al eliminar objetos que **ya no tienen referencias activas**.
* No tienes que eliminar objetos manualmente (como en C/C++), pero **debes entender cuÃ¡ndo un objeto deja de estar referenciado** para evitar desperdicio de memoria (memory leaks).

---

### ğŸ¯ RelaciÃ³n con referencias

Cuando dices:

```java
Nodo a = new Nodo(5);
Nodo b = a;
```

* Solo existe **un objeto** `Nodo(5)` en el heap.
* Tanto `a` como `b` son **referencias en el stack** que apuntan al **mismo objeto en el heap**.

---

## ğŸ§¾ Tabla comparativa: Stack vs Heap

| CaracterÃ­stica | Stack                                          | Heap                                  |
| -------------- | ---------------------------------------------- | ------------------------------------- |
| Almacena       | Variables locales, referencias                 | Objetos creados con `new`             |
| Acceso         | RÃ¡pido                                         | MÃ¡s lento                             |
| Tiempo de vida | Limitado al tiempo de ejecuciÃ³n del mÃ©todo     | Hasta que ya no haya referencias (GC) |
| OrganizaciÃ³n   | LIFO (Ãºltimo en entrar, primero en salir)      | Desorganizado                         |
| GestiÃ³n        | AutomÃ¡tica (crea y destruye marcos por mÃ©todo) | Garbage Collector (automÃ¡tico)        |
| Ejemplo        | `int x = 10; Nodo a;`                          | `a = new Nodo(10);`                   |

---

## ğŸ§  Resumen de manejo de memoria

Comprender la diferencia entre el **stack** y el **heap** te permite:

* Entender por quÃ© los objetos se comportan como lo hacen.
* Anticipar errores por referencias compartidas.
* Visualizar el flujo de memoria en listas enlazadas y otras estructuras dinÃ¡micas.

### ğŸ”¸ Â¿QuÃ© es un apuntador?

En lenguajes como C o C++, los punteros son variables que contienen **direcciones de memoria reales**. Java **no tiene punteros como tales**, pero **sÃ­ maneja referencias**, que conceptualmente cumplen una funciÃ³n parecida:

* Un puntero en C puede ser manipulado directamente (sumas, restas, cast).
* Una referencia en Java **es una abstracciÃ³n controlada**, que apunta a un objeto, pero no puedes ver ni modificar su direcciÃ³n.

> En resumen: **referencias en Java â‰ˆ punteros abstractos y seguros**

---

### ğŸ”¸ Â¿QuÃ© es la instanciaciÃ³n?

La **instanciaciÃ³n** es el proceso de **crear un objeto real a partir de una clase**. Al usar `new`, reservas espacio en memoria para ese objeto y obtienes una **referencia** a su ubicaciÃ³n.

```java
Nodo n = new Nodo(10);
```

* `Nodo` es la clase (molde).
* `new Nodo(10)` crea una instancia del objeto.
* `n` almacena una referencia a esa instancia.

---

### ğŸ”¸ Â¿CÃ³mo se relacionan estos conceptos?

| Concepto      | RelaciÃ³n y comportamiento                                                 |
| ------------- | ------------------------------------------------------------------------- |
| Clase         | Es el **molde** a partir del cual se crean los objetos.                   |
| Objeto        | Es una **instancia real** creada en el heap a partir de una clase.        |
| InstanciaciÃ³n | Es el proceso de **crear un objeto** con `new`.                           |
| Referencia    | Es el **valor que apunta** al objeto en memoria.                          |
| Puntero       | En Java, el concepto es **abstracto**, pero la referencia actÃºa como tal. |

---

## ğŸ§  Tabla resumen
| Elemento           | Â¿QuÃ© es?                                                        | Â¿DÃ³nde vive?                       | Â¿QuÃ© almacena?                             | Â¿Se puede ver su direcciÃ³n? |
| ------------------ | --------------------------------------------------------------- | ---------------------------------- | ------------------------------------------ | --------------------------- |
| `Nodo a;`          | DeclaraciÃ³n de referencia a un objeto `Nodo`                    | Stack (memoria de ejecuciÃ³n)       | Una direcciÃ³n (referencia) o `null`        | No                          |
| `new Nodo(5);`     | InstanciaciÃ³n de un nuevo objeto `Nodo`                         | Heap (memoria dinÃ¡mica)            | Contenido del objeto (`dato`, `siguiente`) | No                          |
| `a = new Nodo(5);` | Se crea un objeto y `a` guarda la referencia                    | `a` en el Stack, objeto en el Heap | Referencia a `Nodo` creado                 | Solo como hash o `toString` |
| `a == b`           | Compara si dos **referencias apuntan al mismo objeto**          | -                                  | Devuelve `true` o `false`                  | No muestra contenido        |
| `a.equals(b)`      | Compara contenido, si estÃ¡ sobreescrito; si no, actÃºa como `==` | -                                  | Devuelve `true` o `false`                  | Depende de la clase         |

---

### ğŸ§© AnalogÃ­a visual:

```text
ğŸ“„ a --> ğŸ  Nodo { dato = 5 }
ğŸ“„ b --> ğŸ  Nodo { dato = 5 }

Si haces b = a, entonces:

ğŸ“„ a --> ğŸ  Nodo { dato = 5 } <--- ğŸ“„ b
```

---

### âœ… ConclusiÃ³n didÃ¡ctica

Antes de construir listas simplemente ligadas, es indispensable que comprendas que:

* **Una variable de tipo objeto no contiene el objeto**, sino una **referencia**.
* Esta referencia **puede cambiar** y puede ser compartida por varias variables.
* El campo `siguiente` en un nodo permite **encadenar referencias**, lo que da origen a estructuras dinÃ¡micas como listas, Ã¡rboles y grafos.

---

## ğŸ”§ Parte 1: Preparando el entorno

### Paso 1: Crea un nuevo proyecto en IntelliJ.

### Paso 2: Crea una clase llamada `Nodo` con el siguiente cÃ³digo:

```java
public class Nodo {
    int dato;
    Nodo siguiente;

    public Nodo(int dato) {
        this.dato = dato;
        this.siguiente = null;
    }

    @Override
    public String toString() {
        return "Nodo@" + Integer.toHexString(System.identityHashCode(this)) + " {dato=" + dato + "}";
    }
}
```

---

## ğŸ‘£ Parte 2: Primer experimento â€“ dos referencias, un mismo objeto

### Paso 3: Crea una clase `Principal1` con el siguiente cÃ³digo:

```java
public class Principal1 {
    public static void main(String[] args) {
        Nodo a = new Nodo(5);
        Nodo b = a;

        System.out.println("a: " + a);
        System.out.println("b: " + b);
        System.out.println("Â¿a == b? " + (a == b));
    }
}
```

### âœ… Resultado esperado:

* `a` y `b` muestran el mismo `hash`.
* `a == b` es `true`.

ğŸ’¡ **ExplicaciÃ³n**: Ambos apuntan al mismo objeto en memoria.

---

## ğŸ‘£ Parte 3: Segundo experimento â€“ dos objetos con el mismo valor

### Paso 4: Crea una clase `Principal2` con el siguiente cÃ³digo:

```java
public class Principal2 {
    public static void main(String[] args) {
        Nodo a = new Nodo(5);
        Nodo b = new Nodo(5);

        System.out.println("a: " + a);
        System.out.println("b: " + b);
        System.out.println("Â¿a == b? " + (a == b));
    }
}
```

### âœ… Resultado esperado:

* `a` y `b` tienen distinto `hash`.
* `a == b` es `false`.

ğŸ’¡ **ExplicaciÃ³n**: Son dos objetos distintos, aunque con el mismo contenido.

---

## ğŸ‘£ Parte 4: Referencias encadenadas

### Paso 5: Crea una clase `Principal3` que encadene nodos manualmente:

```java
public class Principal3 {
    public static void main(String[] args) {
        Nodo primero = new Nodo(1);
        Nodo segundo = new Nodo(2);
        Nodo tercero = new Nodo(3);

        primero.siguiente = segundo;
        segundo.siguiente = tercero;

        Nodo actual = primero;
        while (actual != null) {
            System.out.println(actual);
            actual = actual.siguiente;
        }
    }
}
```

### âœ… Resultado esperado:

Se imprime la direcciÃ³n de cada nodo y su contenido (`dato=1`, `dato=2`, `dato=3`).

ğŸ’¡ **ExplicaciÃ³n**: Los nodos se enlazan manualmente, como una lista simplemente ligada.

---

## ğŸ§  Preguntas de reflexiÃ³n (agregar al cuaderno de ejercicios):

1. Â¿QuÃ© diferencia hay entre `a = b` y `a = new Nodo(b.dato)`?
2. Â¿Por quÃ© `==` devuelve `true` en un caso y `false` en otro?
3. Â¿QuÃ© representa el campo `siguiente`?
4. Â¿QuÃ© pasarÃ­a si asignamos `primero.siguiente = primero`?

---

## ğŸ“Œ Actividad complementaria (agregar al cuaderno de ejercicios):

Modificar la clase `Nodo` para que imprima, ademÃ¡s del `dato`, el `hash` del nodo siguiente si no es `null`, para observar cÃ³mo estÃ¡n conectados:

```java
@Override
public String toString() {
    return "Nodo@" + Integer.toHexString(System.identityHashCode(this)) + 
           " {dato=" + dato + ", siguiente=" + 
           (siguiente != null ? "Nodo@" + Integer.toHexString(System.identityHashCode(siguiente)) : "null") + "}";
}
```

---

## ğŸ“ ConclusiÃ³n

Esta prÃ¡ctica permite visualizar el **modelo mental correcto** para trabajar con objetos y estructuras enlazadas, antes de implementar mÃ©todos mÃ¡s avanzados como `insertar`, `eliminar` o `buscar`.









