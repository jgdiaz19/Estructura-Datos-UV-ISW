## ğŸ§ª Ejercicio 4: InversiÃ³n lÃ³gica de la lista doblemente ligada


### ğŸ¯ Objetivo del ejercicio

Permitir que el usuario **invierta el orden de los elementos** de una lista doblemente ligada, reconfigurando internamente los punteros `siguiente` y `anterior` de cada nodo, y actualizando correctamente la `cabeza` y la `cola`.

Este ejercicio permite reforzar el entendimiento del uso y actualizaciÃ³n de punteros dobles.


## ğŸ“ Archivos involucrados

* `NodoDoble.java` âœ… (sin cambios)
* `ListaDoble.java` âœ… (modificado: nuevo mÃ©todo)
* `MenuListaDoble.java` âœ… (modificado: nueva opciÃ³n)
* `Principal.java` âœ… (sin cambios)


## ğŸ”§ Cambios en `ListaDoble.java`

### â• MÃ©todo: `invertir()`

```java
public void invertir() {
    if (cabeza == null) {
        System.out.println("La lista estÃ¡ vacÃ­a. No se puede invertir.");
        return;
    }

    NodoDoble actual = cabeza;
    NodoDoble temporal = null;

    while (actual != null) {
        // Intercambiar punteros
        temporal = actual.anterior;
        actual.anterior = actual.siguiente;
        actual.siguiente = temporal;

        // Mover al siguiente nodo en la direcciÃ³n original
        actual = actual.anterior;
    }

    // Intercambiar cabeza y cola
    if (temporal != null) {
        cabeza = temporal.anterior;
        cola = cabeza;
        while (cola != null && cola.siguiente != null) {
            cola = cola.siguiente;
        }
    }

    System.out.println("La lista ha sido invertida.");
}
```


### ğŸ§  ExplicaciÃ³n paso a paso:

1. **ValidaciÃ³n**: Si la lista estÃ¡ vacÃ­a, se aborta la operaciÃ³n.
2. **Recorrido**: Se recorre la lista intercambiando, en cada nodo, los punteros `siguiente` y `anterior`.
3. **Avance**: Luego de intercambiar los punteros, el nodo siguiente es el `anterior`, por lo tanto `actual = actual.anterior`.
4. **ReasignaciÃ³n**: Al final, `temporal` apuntarÃ¡ al nodo anterior al nuevo inicio de la lista; asÃ­ se actualiza correctamente la `cabeza`.
5. **Recalcular cola**: Se recorre desde la nueva cabeza para determinar el nuevo nodo final (`cola`).


## ğŸ§­ Cambios en `MenuListaDoble.java`

### ğŸ”¢ Agrega la opciÃ³n al menÃº:

```java
System.out.println("9. Invertir la lista");
```

### â• Agrega el `case` en el `switch(opcion)`:

```java
case 9 -> lista.invertir();
```

---

## âœ… Ejemplo de prueba sugerido

### Antes de invertir:

Lista: `10 â‡„ 20 â‡„ 30 â‡„ 40`

### DespuÃ©s de invertir:

Lista: `40 â‡„ 30 â‡„ 20 â‡„ 10`


## ğŸ§  Preguntas de reflexiÃ³n (agregar al cuaderno de ejercicios)

* Â¿QuÃ© ocurre si no se actualiza la cabeza correctamente despuÃ©s de invertir?
* Â¿Es posible realizar esta inversiÃ³n en una lista simplemente ligada? Â¿Por quÃ©?
* Â¿CÃ³mo afecta esta operaciÃ³n al rendimiento si la lista tiene miles de nodos?


## ğŸ“ Ejercicios complementarios â€“ Ejercicio 4 (InversiÃ³n de lista)


### ğŸ”¹ Ejercicio C1: Invertir solo un segmento de la lista (sublista)

**Objetivo**: Implementar un mÃ©todo que permita invertir Ãºnicamente los nodos comprendidos entre dos posiciones dadas (inclusive).

**Firma sugerida**:

```java
public void invertirSegmento(int desde, int hasta)
```

**LÃ³gica**:

* Validar que `desde` y `hasta` sean posiciones vÃ¡lidas y que `desde < hasta`.
* Ubicar los nodos de inicio y fin del segmento.
* Invertir las conexiones dentro del segmento.
* Reconectar el segmento invertido con el resto de la lista (si existe).

**Ejemplo**:
Lista original: `10 â‡„ 20 â‡„ 30 â‡„ 40 â‡„ 50`
ParÃ¡metros: `desde = 1`, `hasta = 3`
Resultado: `10 â‡„ 40 â‡„ 30 â‡„ 20 â‡„ 50`


### ğŸ”¹ Ejercicio C2: Verificar si la lista es simÃ©trica (palÃ­ndroma)

**Objetivo**: Comprobar si la lista contiene los mismos elementos al recorrerla desde el inicio y desde el final.

**Firma sugerida**:

```java
public boolean esSimetrica()
```

**LÃ³gica**:

* Usar dos punteros: uno desde la cabeza, otro desde la cola.
* Comparar los valores avanzando desde ambos extremos hacia el centro.
* Si todos los pares coinciden, retornar `true`; de lo contrario, `false`.

**Ejemplo**:

* `10 â‡„ 20 â‡„ 30 â‡„ 20 â‡„ 10` â†’ `true`
* `5 â‡„ 15 â‡„ 25 â‡„ 35` â†’ `false`


### ğŸ”¹ Ejercicio C3: Restaurar la lista a su estado original despuÃ©s de invertir

**Objetivo**: Almacenar los elementos de la lista en una estructura auxiliar antes de invertirla, y luego restaurarla a su estado inicial sin utilizar nuevamente la operaciÃ³n `invertir()`.

**Firma sugerida**:

```java
public void restaurarDesdeArreglo(int[] valores)
```

**LÃ³gica**:

* Antes de invertir, recorrer la lista y guardar los valores en un arreglo.
* DespuÃ©s de invertir, eliminar todos los nodos.
* Insertar los valores del arreglo uno por uno en orden.


## ğŸ§ª Casos de prueba â€“ Ejercicios complementarios del Ejercicio 4


### ğŸ”¹ Ejercicio C1: Invertir solo un segmento de la lista

#### ğŸ“Œ Caso de prueba 1

**Entrada**:

* Lista: `10 â‡„ 20 â‡„ 30 â‡„ 40 â‡„ 50`
* Invertir segmento desde posiciÃ³n `1` hasta posiciÃ³n `3`

**Proceso esperado**:

* Sublista `20 â‡„ 30 â‡„ 40` se invierte
* Nueva secuencia: `10 â‡„ 40 â‡„ 30 â‡„ 20 â‡„ 50`

**Resultado esperado**:
`10 â‡„ 40 â‡„ 30 â‡„ 20 â‡„ 50`


#### ğŸ“Œ Caso de prueba 2

**Entrada**:

* Lista: `1 â‡„ 2 â‡„ 3 â‡„ 4 â‡„ 5 â‡„ 6`
* Invertir segmento desde posiciÃ³n `0` hasta posiciÃ³n `5` (toda la lista)

**Proceso esperado**:

* Se invierte toda la lista

**Resultado esperado**:
`6 â‡„ 5 â‡„ 4 â‡„ 3 â‡„ 2 â‡„ 1`


#### ğŸ“Œ Caso de prueba 3 (rango invÃ¡lido)

**Entrada**:

* Lista: `100 â‡„ 200 â‡„ 300`
* Invertir segmento desde posiciÃ³n `2` hasta `1`

**Proceso esperado**:

* OperaciÃ³n invÃ¡lida, no se realiza la inversiÃ³n

**Resultado esperado**:
`"Rango de posiciones invÃ¡lido"`
Lista: `100 â‡„ 200 â‡„ 300`


### ğŸ”¹ Ejercicio C2: Verificar si la lista es simÃ©trica

#### ğŸ“Œ Caso de prueba 1

**Entrada**:

* Lista: `5 â‡„ 10 â‡„ 15 â‡„ 10 â‡„ 5`

**Proceso esperado**:

* Comparar extremos: `5 == 5`, `10 == 10`, `15 == 15`
* Todos coinciden

**Resultado esperado**:
`true`


#### ğŸ“Œ Caso de prueba 2

**Entrada**:

* Lista: `1 â‡„ 2 â‡„ 3 â‡„ 4`

**Proceso esperado**:

* Comparar extremos: `1 != 4`
* Diferencia detectada

**Resultado esperado**:
`false`


#### ğŸ“Œ Caso de prueba 3 (un solo nodo)

**Entrada**:

* Lista: `99`

**Proceso esperado**:

* Una sola comparaciÃ³n consigo mismo

**Resultado esperado**:
`true`


### ğŸ”¹ Ejercicio C3: Restaurar la lista a su estado original despuÃ©s de invertir

#### ğŸ“Œ Caso de prueba 1

**Entrada**:

* Lista original: `10 â‡„ 20 â‡„ 30 â‡„ 40`
* Valores respaldados: `[10, 20, 30, 40]`
* Se invierte la lista, luego se elimina todo y se restauran los valores

**Proceso esperado**:

* ReconstrucciÃ³n exacta de la secuencia original

**Resultado esperado**:
`10 â‡„ 20 â‡„ 30 â‡„ 40`


#### ğŸ“Œ Caso de prueba 2

**Entrada**:

* Lista original: `1 â‡„ 2 â‡„ 3`
* Valores respaldados: `[1, 2, 3]`
* RestauraciÃ³n en una lista que tenÃ­a estado diferente

**Resultado esperado**:
Lista igual al respaldo: `1 â‡„ 2 â‡„ 3`


#### ğŸ“Œ Caso de prueba 3 (lista vacÃ­a restaurada)

**Entrada**:

* Lista vacÃ­a
* Arreglo respaldo: `[100, 200, 300]`

**Proceso esperado**:

* Se insertan los valores uno a uno

**Resultado esperado**:
`100 â‡„ 200 â‡„ 300`
