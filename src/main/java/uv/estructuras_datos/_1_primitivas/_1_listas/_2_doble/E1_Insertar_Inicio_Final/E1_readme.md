
## **Ejercicio 1: Implementaci√≥n, inserci√≥n al inicio y al final en listas doblemente ligadas**.

### ‚úÖ Objetivo:

Implementar una lista doblemente ligada que permita insertar elementos al inicio y al final, y recorrerla en ambas direcciones.


---

## 1. Introducci√≥n

Las listas doblemente ligadas constituyen una estructura de datos lineal que, a diferencia de las listas simplemente ligadas, mantienen un doble enlace entre sus nodos: uno hacia el nodo siguiente y otro hacia el nodo anterior. Esta caracter√≠stica permite un recorrido bidireccional de la lista, lo que incrementa su flexibilidad en operaciones de inserci√≥n y eliminaci√≥n.

En contextos donde se requiere desplazamiento eficiente hacia adelante y hacia atr√°s, o eliminar nodos intermedios con rapidez, las listas doblemente ligadas representan una alternativa m√°s vers√°til que las listas simples o los arreglos din√°micos.

---

## 2. Estructura de un nodo doblemente ligado

Cada nodo de una lista doblemente ligada est√° compuesto por tres campos:

* Un **campo de datos** que almacena el valor del nodo.
* Una **referencia al siguiente nodo** de la lista.
* Una **referencia al nodo anterior**.

Formalmente, puede representarse de la siguiente manera:

```
[nodo_anterior] ‚Üê [ DATO ] ‚Üí [nodo_siguiente]
```

Cuando se trata del primer nodo, su campo `anterior` es `null`; de forma an√°loga, el √∫ltimo nodo tendr√° `null` en el campo `siguiente`.

---

## 3. Propiedades de la lista doblemente ligada

Una lista doblemente ligada puede caracterizarse por las siguientes propiedades:

* Posee una referencia al primer nodo (`cabeza`) y com√∫nmente tambi√©n al √∫ltimo (`cola`), lo cual permite accesos eficientes desde ambos extremos.
* Cada nodo conoce tanto a su predecesor como a su sucesor inmediato.
* Permite recorrer la lista en **dos direcciones** sin necesidad de recorrerla completa desde el inicio.
* Facilita operaciones de eliminaci√≥n e inserci√≥n de nodos en tiempo constante si se tiene una referencia directa al nodo en cuesti√≥n.

---

## 4. Operaciones b√°sicas

Las principales operaciones que se pueden realizar sobre una lista doblemente ligada incluyen:

### 4.1. Inserci√≥n al inicio

Se crea un nuevo nodo y se ajustan las referencias para que este nuevo nodo apunte al anterior primer nodo, y la cabeza de la lista se actualice al nuevo nodo.

### 4.2. Inserci√≥n al final

El nuevo nodo se conecta despu√©s del √∫ltimo nodo existente y se actualiza la referencia de la cola.

### 4.3. Inserci√≥n en una posici√≥n espec√≠fica

Implica recorrer la lista hasta la posici√≥n deseada, y luego modificar las referencias de los nodos anterior y siguiente para insertar el nuevo nodo entre ellos.

### 4.4. Eliminaci√≥n de un nodo

Dado un nodo a eliminar, se ajustan las referencias del nodo anterior y siguiente de forma que excluyan al nodo actual de la cadena. Si el nodo est√° al inicio o al final, tambi√©n se actualiza la cabeza o la cola, respectivamente.

### 4.5. B√∫squeda

Consiste en recorrer secuencialmente la lista en una de las dos direcciones para localizar un nodo que contenga un valor espec√≠fico.

### 4.6. Recorrido desde la cabeza o la cola

Gracias a los punteros dobles, la lista puede recorrerse en orden directo o inverso, seg√∫n se requiera.

---

## 5. Comparaci√≥n con otras estructuras

| Caracter√≠stica                           | Lista simplemente ligada         | Lista doblemente ligada |
| ---------------------------------------- | -------------------------------- | ----------------------- |
| Enlace hacia el anterior                 | No                               | S√≠                      |
| Recorrido inverso                        | No                               | S√≠                      |
| Inserci√≥n/eliminaci√≥n r√°pida en extremos | S√≠ (inicio), no (final sin cola) | S√≠ en ambos extremos    |
| Uso de memoria                           | Menor (una referencia)           | Mayor (dos referencias) |

---

## 6. Consideraciones de implementaci√≥n

Aunque las listas doblemente ligadas ofrecen mayor flexibilidad que las listas simples, tambi√©n implican un mayor uso de memoria debido a los dos punteros por nodo. Asimismo, la implementaci√≥n requiere atenci√≥n especial para mantener la integridad de las referencias al insertar o eliminar nodos, particularmente en los casos de extremos o listas con un solo elemento.

Es buena pr√°ctica mantener referencias expl√≠citas tanto al inicio (`cabeza`) como al final (`cola`) para optimizar las operaciones en ambos sentidos.

---

¬øDeseas que ahora integremos esta secci√≥n como parte del `README.md` del m√≥dulo `listas/doble`, o prefieres que tambi√©n lo convierta en una versi√≥n `.md` o `.pdf` para integrarlo directamente en el repositorio?

> A contiunaci√≥n vamos a desarrollar el codigo para hacer la implementacion de las primeras operacion de una lista doble, copia y pega el codigo y posteriormente realiza los ejercicios propuestos

## üìÅ Archivos a utilizar

* `NodoDoble.java`: representa cada nodo con referencias a anterior y siguiente.
* `ListaDoble.java`: contiene la l√≥gica de inserci√≥n y recorrido.
* `MenuListaDoble.java`: interfaz de men√∫ para interactuar con la lista.
* `Principal.java`: clase de arranque del programa.

---

## üîß Funcionalidades implementadas

* Insertar elementos al inicio.
* Insertar elementos al final.
* Recorrer la lista desde el inicio hacia el final.
* Recorrer la lista desde el final hacia el inicio.

---

## 1. `NodoDoble.java`

```java
public class NodoDoble {
    int dato;
    NodoDoble siguiente;
    NodoDoble anterior;

    public NodoDoble(int dato) {
        this.dato = dato;
        this.siguiente = null;
        this.anterior = null;
    }
}
```
### üß† ¬øQu√© es `NodoDoble.java`?

Un **nodo doble** es una **unidad b√°sica de una lista doblemente ligada**. A diferencia de los nodos en una lista simple, que solo apuntan al siguiente nodo, en una lista doble **cada nodo tiene dos enlaces**:

* Uno que apunta al siguiente nodo (`siguiente`)
* Uno que apunta al nodo anterior (`anterior`)

Esto permite **recorrer la lista en ambas direcciones**: de principio a fin y de fin a principio.

### üîé Desglose por partes:

* `int dato`: almacena el valor del nodo (puede ser otro tipo primitivo o un objeto en futuras versiones).
* `NodoDoble siguiente`: referencia al siguiente nodo de la lista.
* `NodoDoble anterior`: referencia al nodo anterior de la lista.
* El constructor:

    * Recibe el valor (`dato`) y deja los enlaces `null`, porque cuando se crea el nodo a√∫n no est√° conectado a otros nodos.

### üìå Ejemplo visual:

```text
null ‚Üê [10] ‚Üí null
```

Luego de insertar otro nodo al final:

```text
null ‚Üê [10] ‚áÑ [20] ‚Üí null
```

---

## 2. `ListaDoble.java`

```java
public class ListaDoble {
    private NodoDoble cabeza;
    private NodoDoble cola;

    public ListaDoble() {
        cabeza = null;
        cola = null;
    }

    public void insertarAlInicio(int dato) {
        NodoDoble nuevo = new NodoDoble(dato);
        if (cabeza == null) {
            cabeza = cola = nuevo;
        } else {
            nuevo.siguiente = cabeza;
            cabeza.anterior = nuevo;
            cabeza = nuevo;
        }
    }

    public void insertarAlFinal(int dato) {
        NodoDoble nuevo = new NodoDoble(dato);
        if (cola == null) {
            cabeza = cola = nuevo;
        } else {
            cola.siguiente = nuevo;
            nuevo.anterior = cola;
            cola = nuevo;
        }
    }

    public void imprimirDesdeInicio() {
        NodoDoble actual = cabeza;
        System.out.print("Inicio ‚Üí ");
        while (actual != null) {
            System.out.print(actual.dato + " ‚áÑ ");
            actual = actual.siguiente;
        }
        System.out.println("null");
    }

    public void imprimirDesdeFinal() {
        NodoDoble actual = cola;
        System.out.print("Fin ‚Üí ");
        while (actual != null) {
            System.out.print(actual.dato + " ‚áÑ ");
            actual = actual.anterior;
        }
        System.out.println("null");
    }
}
```

## üß† ¬øQu√© es `ListaDoble`?

Es una clase que **administra y controla el funcionamiento** de una lista doblemente ligada. Guarda la referencia al **primer nodo** (`cabeza`) y al **√∫ltimo nodo** (`cola`). Esto permite operaciones eficientes desde ambos extremos.

---

### üîç Atributos:

* `cabeza`: es el primer nodo de la lista.
* `cola`: es el √∫ltimo nodo de la lista.

---

### üìå M√©todo `insertarAlInicio(int dato)`

```java
public void insertarAlInicio(int dato) {
    NodoDoble nuevo = new NodoDoble(dato);
    if (cabeza == null) {
        cabeza = cola = nuevo;
    } else {
        nuevo.siguiente = cabeza;
        cabeza.anterior = nuevo;
        cabeza = nuevo;
    }
}
```

#### üîç L√≥gica:

1. Se crea un nuevo nodo.
2. Si la lista est√° vac√≠a:

    * Ese nodo ser√° **el primero y el √∫ltimo** al mismo tiempo.
3. Si ya hay elementos:

    * El nuevo nodo se conecta **antes de la cabeza actual**.
    * Se actualiza `cabeza` para que apunte al nuevo nodo.

---

### üìå M√©todo `insertarAlFinal(int dato)`

```java
public void insertarAlFinal(int dato) {
    NodoDoble nuevo = new NodoDoble(dato);
    if (cola == null) {
        cabeza = cola = nuevo;
    } else {
        cola.siguiente = nuevo;
        nuevo.anterior = cola;
        cola = nuevo;
    }
}
```

#### üîç L√≥gica:

1. Se crea un nodo nuevo.
2. Si la lista est√° vac√≠a:

    * El nodo es tanto cabeza como cola.
3. Si no:

    * Se conecta despu√©s de la cola actual.
    * La cola se actualiza al nuevo nodo.

---

### üìå M√©todo `imprimirDesdeInicio()`

```java
public void imprimirDesdeInicio() {
    NodoDoble actual = cabeza;
    System.out.print("Inicio ‚Üí ");
    while (actual != null) {
        System.out.print(actual.dato + " ‚áÑ ");
        actual = actual.siguiente;
    }
    System.out.println("null");
}
```

#### üîç L√≥gica:

* Se empieza desde la `cabeza` y se avanza nodo por nodo usando `siguiente`.
* Se imprime cada valor hasta llegar al final (`null`).

---

### üìå M√©todo `imprimirDesdeFinal()`

```java
public void imprimirDesdeFinal() {
    NodoDoble actual = cola;
    System.out.print("Fin ‚Üí ");
    while (actual != null) {
        System.out.print(actual.dato + " ‚áÑ ");
        actual = actual.anterior;
    }
    System.out.println("null");
}
```

#### üîç L√≥gica:

* Comienza desde la `cola` y recorre la lista hacia atr√°s usando `anterior`.
* Permite comprobar que los enlaces `anterior` est√°n bien definidos.

---

## üß† Resumen

Estas dos clases (`NodoDoble` y `ListaDoble`) permiten implementar una estructura eficiente para gestionar datos **desde ambos extremos**. Entender c√≥mo conectar y actualizar correctamente los nodos es esencial para evitar errores de referencia y garantizar que la lista est√© bien formada.


---

## 3. `MenuListaDoble.java`

```java
import java.util.Scanner;

public class MenuListaDoble {
    private final ListaDoble lista;
    private final Scanner scanner;

    public MenuListaDoble() {
        this.lista = new ListaDoble();
        this.scanner = new Scanner(System.in);
    }

    public void mostrarMenu() {
        int opcion;

        do {
            System.out.println("\n--- MEN√ö: Lista Doble (Inicio y Final) ---");
            System.out.println("1. Insertar al inicio");
            System.out.println("2. Insertar al final");
            System.out.println("3. Imprimir desde el inicio");
            System.out.println("4. Imprimir desde el final");
            System.out.println("0. Salir");
            System.out.print("Selecciona una opci√≥n: ");
            opcion = scanner.nextInt();

            switch (opcion) {
                case 1 -> {
                    System.out.print("Introduce un n√∫mero: ");
                    int numero = scanner.nextInt();
                    lista.insertarAlInicio(numero);
                    System.out.println("N√∫mero insertado al inicio.");
                }
                case 2 -> {
                    System.out.print("Introduce un n√∫mero: ");
                    int numero = scanner.nextInt();
                    lista.insertarAlFinal(numero);
                    System.out.println("N√∫mero insertado al final.");
                }
                case 3 -> lista.imprimirDesdeInicio();
                case 4 -> lista.imprimirDesdeFinal();
                case 0 -> System.out.println("Fin del programa.");
                default -> System.out.println("Opci√≥n inv√°lida.");
            }

        } while (opcion != 0);
    }
}
```

---

## 4. `Principal.java`

```java
public class Principal {
    public static void main(String[] args) {
        MenuListaDoble menu = new MenuListaDoble();
        menu.mostrarMenu();
    }
}
```

---


## üß™ Escenario de prueba recomendado

1. Insertar 10 al **inicio**
2. Insertar 20 al **final**
3. Insertar 30 al **inicio**
4. Mostrar la lista desde el inicio ‚Üí `30 ‚áÑ 10 ‚áÑ 20`
5. Mostrar la lista desde el final ‚Üí `20 ‚áÑ 10 ‚áÑ 30`

---

## üß† Preguntas de reflexi√≥n (agregar al cuaderno de ejercicios) 

* ¬øQu√© ventaja tiene una lista doble respecto a una simple?
* ¬øC√≥mo afecta al rendimiento recorrer la lista desde el final?
* ¬øEs necesario usar dos punteros (`cabeza` y `cola`)? ¬øPor qu√©?

---

## üìé Ejercicios complementarios

Los siguientes ejercicios est√°n dise√±ados para extender el uso del c√≥digo actual de inserci√≥n y recorrido de listas doblemente ligadas. Estos retos permiten reforzar el uso de punteros y el an√°lisis de la estructura de la lista.

---

### üîπ Ejercicio C1: Contar elementos de la lista

**Objetivo**: Implementar un m√©todo que recorra la lista desde la cabeza y retorne la cantidad de nodos.

**Resultado esperado**:
Si la lista contiene `10 ‚áÑ 20 ‚áÑ 30`, el m√©todo debe retornar `3`.

---

### üîπ Ejercicio C2: Mostrar el primer y √∫ltimo elemento

**Objetivo**: Permitir al usuario consultar el primer y el √∫ltimo elemento sin recorrer la lista.

**Complemento en el men√∫**:
Agregar opciones como:

* `5. Mostrar primer elemento`
* `6. Mostrar √∫ltimo elemento`

---

### üîπ Ejercicio C3: Mostrar la lista en formato √≠ndice-valor

**Objetivo**: Imprimir los elementos de la lista junto con su posici√≥n (empezando desde 0).

**Ejemplo de salida:**

```
[0] 10
[1] 20
[2] 30
```

---

### üîπ Ejercicio C4: Verificar si la lista est√° vac√≠a

**Objetivo**: Implementar una validaci√≥n r√°pida para saber si la lista contiene elementos.

**Complemento en el men√∫:**
Agregar opci√≥n `7. Verificar si la lista est√° vac√≠a`, que imprima:

* `"La lista est√° vac√≠a"`
* o `"La lista contiene elementos"`

---

### üîπ Ejercicio C5: Vaciar la lista

**Objetivo**: Permitir que el usuario borre todos los elementos de la lista.


> Esto elimina la referencia a los nodos; el recolector de basura se encarga del resto.


